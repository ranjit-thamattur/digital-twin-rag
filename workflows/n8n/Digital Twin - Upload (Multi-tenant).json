{
  "name": "Digital Twin - Upload (Multi-tenant)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "upload-document",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "2a45fce9-2ee3-4025-8583-01ba12b1c664",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "webhookId": "6224da71-236f-4ca1-be46-d63f7946a7a2"
    },
    {
      "parameters": {
        "jsCode": "// Set Basic Info - Extract metadata\nconst item = $input.first();\nif (!item) {\n  return [{ json: { error: \"No input\" } }];\n}\n\nconst data = item.json;\nconst fileName = data.fileName || data.body?.fileName || 'document.txt';\nconst content = data.content || data.body?.content || '';\n\nconst metadata = data.metadata || data.body?.metadata || {};\nconst tenantId = metadata.tenantId || 'default';\nconst personaId = metadata.personaId || 'default';\n\nconst collectionName = `${tenantId}_knowledge`;\n\nreturn [{\n  json: {\n    fileName,\n    content: String(content),\n    uploadDate: new Date().toISOString(),\n    tenantId,\n    personaId,\n    collectionName\n  }\n}];"
      },
      "id": "0dfc97ad-49ea-42d3-a4bd-eddcea018cc2",
      "name": "Set Basic Info",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Check if collection exists, create if not\nconst item = $input.first();\nconst collectionName = item.json.collectionName;\n\nconsole.log(`Checking if collection ${collectionName} exists...`);\n\nlet collectionExists = false;\ntry {\n    const checkResponse = await this.helpers.httpRequest({\n        method: 'GET',\n        url: `http://qdrant:6333/collections/${collectionName}`,\n        json: true\n    });\n    collectionExists = true;\n    console.log(`Collection ${collectionName} exists`);\n} catch (error) {\n    // 404 means collection doesn't exist - this is expected\n    console.log(`Collection ${collectionName} not found, will create it`);\n    collectionExists = false;\n}\n\n// Create collection if it doesn't exist\nif (!collectionExists) {\n    console.log(`Creating collection ${collectionName}...`);\n\n    const createResponse = await this.helpers.httpRequest({\n        method: 'PUT',\n        url: `http://qdrant:6333/collections/${collectionName}`,\n        body: {\n            vectors: {\n                size: 768,\n                distance: 'Cosine'\n            }\n        },\n        json: true\n    });\n\n    console.log(`Collection created successfully:`, createResponse);\n}\n\n// Pass through original data\nreturn [item];\n"
      },
      "id": "1829cec1-baac-42d1-85df-ce2ccf8c121d",
      "name": "Check & Create Collection",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        352,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Split Chunks\nconst item = $input.first();\nconst content = item.json.content || '';\nconst chunkSize = 2000;\nconst overlap = 200;\n\nconst items = [];\nlet start = 0;\nlet chunkIndex = 0;\n\nwhile (start < content.length) {\n  const end = Math.min(start + chunkSize, content.length);\n  items.push({\n    json: {\n      text: content.substring(start, end),\n      fileName: item.json.fileName,\n      chunkIndex: chunkIndex,\n      uploadDate: item.json.uploadDate,\n      tenantId: item.json.tenantId,\n      personaId: item.json.personaId,\n      collectionName: item.json.collectionName\n    }\n  });\n  start += chunkSize - overlap;\n  chunkIndex++;\n}\n\nreturn items;"
      },
      "id": "70fa70b1-a6a2-47d9-9cb6-6315c0072763",
      "name": "Split Chunks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1152,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate Embeddings for ALL chunks - BATCH PROCESSING\nconst items = $input.all();\nconst results = [];\n\nconsole.log(`Processing ${items.length} chunks...`);\n\nfor (const item of items) {\n  const text = item.json.text || '';\n  const cleanedText = text.replace(/\\n+/g, ' ').replace(/\\s+/g, ' ').trim();\n  \n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: 'http://ollama:11434/api/embeddings',\n    body: { model: 'nomic-embed-text', prompt: cleanedText },\n    json: true\n  });\n  \n  results.push({\n    json: {\n      embedding: response.embedding,\n      text: item.json.text,\n      fileName: item.json.fileName,\n      chunkIndex: item.json.chunkIndex,\n      uploadDate: item.json.uploadDate,\n      tenantId: item.json.tenantId,\n      personaId: item.json.personaId,\n      collectionName: item.json.collectionName\n    }\n  });\n}\n\nconsole.log(`Generated ${results.length} embeddings`);\nreturn results;"
      },
      "id": "0a5dcc18-1ba1-4ea3-9357-57154875c764",
      "name": "Generate Embeddings (All)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1376,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare ALL Qdrant Points - BATCH\nconst items = $input.all();\nconst results = [];\n\nfunction generateUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nfor (const item of items) {\n  results.push({\n    json: {\n      id: generateUUID(),\n      vector: item.json.embedding,\n      collectionName: item.json.collectionName,\n      payload: {\n        text: item.json.text,\n        fileName: item.json.fileName,\n        chunkIndex: item.json.chunkIndex,\n        uploadDate: item.json.uploadDate,\n        tenantId: item.json.tenantId,\n        personaId: item.json.personaId\n      }\n    }\n  });\n}\n\nconsole.log(`Prepared ${results.length} points`);\nreturn results;"
      },
      "id": "ffa5e6e9-58e7-4105-b484-5571d67bec28",
      "name": "Prepare Points (All)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Batch ALL points into single JSON for insert\nconst items = $input.all();\n\nconst points = items.map(item => ({\n  id: item.json.id,\n  vector: item.json.vector,\n  payload: item.json.payload\n}));\n\nconst collectionName = items[0]?.json.collectionName;\n\nconsole.log(`Batching ${points.length} points for collection: ${collectionName}`);\n\nreturn [{\n  json: {\n    points: points,\n    collectionName: collectionName\n  }\n}];"
      },
      "id": "c98cbf40-376f-40ec-930a-c2401c4aa089",
      "name": "Batch Points",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1776,
        0
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=http://qdrant:6333/collections/{{$json.collectionName}}/points?wait=true",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { points: $json.points } }}",
        "options": {}
      },
      "id": "0933feab-6be9-4114-b7ee-0d47a77a0a7d",
      "name": "Batch Insert Qdrant",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1952,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "const batchNode = $('Batch Points').first().json;\nconst insertResponse = $input.first().json;\n\nreturn [{\n  json: {\n    success: true,\n    message: `Indexed ${batchNode.points.length} chunks`,\n    fileName: batchNode.points[0]?.payload?.fileName || 'unknown',\n    tenantId: batchNode.points[0]?.payload?.tenantId || 'unknown',\n    personaId: batchNode.points[0]?.payload?.personaId || 'unknown',\n    collectionName: batchNode.collectionName,\n    chunksIndexed: batchNode.points.length,\n    qdrantResponse: insertResponse,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "28d34c74-3c9f-4936-b064-fc04ec47b953",
      "name": "Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2128,
        0
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Set Basic Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Basic Info": {
      "main": [
        [
          {
            "node": "Check & Create Collection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check & Create Collection": {
      "main": [
        [
          {
            "node": "Split Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Chunks": {
      "main": [
        [
          {
            "node": "Generate Embeddings (All)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embeddings (All)": {
      "main": [
        [
          {
            "node": "Prepare Points (All)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Points (All)": {
      "main": [
        [
          {
            "node": "Batch Points",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Points": {
      "main": [
        [
          {
            "node": "Batch Insert Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Insert Qdrant": {
      "main": [
        [
          {
            "node": "Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "30b2fe7f-6fe6-4138-aaff-4410e1a91016",
  "meta": {
    "instanceId": "98021569524151863a958a43edb78ea0cce967957ce426dd6107c29f5967511b"
  },
  "id": "jiiWtbun08oc6HVwx4Ldq",
  "tags": []
}